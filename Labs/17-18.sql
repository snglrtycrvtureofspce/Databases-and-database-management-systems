/* 17 */
SELECT AVG(price) AS average_price FROM products;

SELECT SUM(delivery_cost) AS total_cost FROM orders;

SELECT MIN(price) AS min_price FROM products;

SELECT MAX(price) AS max_price FROM products;

SELECT COUNT(*) AS total_orders FROM orders;

/* Количество заказов по каждому типу доставки: */
SELECT delivery_type, COUNT(*) AS total_orders FROM orders GROUP BY delivery_type;

/* Количество заказов, сделанных каждым заказчиком */
SELECT customer_id, COUNT(*) AS total_orders FROM orders GROUP BY customer_id;

/* Средняя стоимость доставки по каждому типу доставки */
SELECT delivery_type, AVG(delivery_cost) AS average_delivery_cost FROM orders GROUP BY delivery_type;

/* Общая стоимость доставки для каждого заказчика */
SELECT customer_id, SUM(delivery_cost) AS total_delivery_cost FROM orders GROUP BY customer_id;

/* Заказы, у которых общая стоимость доставки превышает 1000 */
SELECT * FROM orders WHERE delivery_cost > 1000;

/*
1) Особенности использования агрегатных функций:
   1.1) Агрегатные функции выполняют вычисления над набором значений столбцов и возвращают единственное значение результатов.
   1.2) Обычно агрегатные функции применяются в комбинации с операторами SELECT, GROUP BY и HAVING.
   1.3) Некоторые из популярных агрегатных функций включают AVG (среднее значение), SUM (сумма), MIN (минимальное значение), 
   MAX (максимальное значение) и COUNT (количество).
   1.4) Агрегатные функции могут использоваться для анализа данных, создания сводных отчетов и выполнения различных вычислений.
2) Оператор GROUP BY используется для группировки результатов запроса по одному или нескольким столбцам. 
Он позволяет объединить строки с одинаковыми значениями в указанных столбцах и применить агрегатные функции 
к каждой группе отдельно. GROUP BY обычно используется в комбинации с агрегатными функциями, 
чтобы выполнить вычисления по группам данных.
3) Оператор HAVING используется для отбора данных после осуществления группировки (GROUP BY). 
Он позволяет задавать условия, которым должны удовлетворять группы данных, чтобы быть включенными в результат. 
HAVING применяется после GROUP BY и позволяет фильтровать группы на основе агрегатных функций или других выражений.
4) При группировке данных, если среди значений столбца встречается значение NULL, 
то NULL-значения будут сгруппированы отдельно от других значений. Это означает, 
что каждая группа будет содержать NULL-значения отдельно от других ненулевых значений. 
Если необходимо объединить NULL-значения с другой группой, 
можно использовать функцию агрегации COALESCE или условие в операторе HAVING, 
чтобы учесть NULL-значения при определении условий фильтрации или вычислений.
*/

/* 18 */

/* имена клиентов, которые разместили заказы на товары стоимостью более 100 */
SELECT customer_name [ФИО клиента]
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE product_id IN (SELECT product_id FROM products WHERE price > 100.00));

/* общее количество каждого проданного товара */
SELECT product_name [Название продукта], SUM(quantity) AS ПРОДАНО_ТОВАРА
FROM products
JOIN orders ON products.product_id = orders.product_id
GROUP BY product_name;

/* клиенты, разместившие заказы на товары, которые ДОСТУПНЫ для доставки */
SELECT customer_name [ФИО клиента]
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE product_id IN (SELECT product_id FROM products WHERE delivery_available = 0));

/* товары, которые были заказаны более НУЛЯ раз */
SELECT product_name [Название продукта]
FROM products
WHERE product_id IN (SELECT product_id FROM orders GROUP BY product_id HAVING COUNT(*) > 0);

/* клиенты, разместившие заказы на товары со стоимостью доставки более 500 */
SELECT customer_name [ФИО клиента]
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE delivery_cost > 500.00);

/* продукты, которые никогда не были заказаны */
SELECT product_name [Название продукта]
FROM products
WHERE product_id NOT IN (SELECT product_id FROM orders);

/* клиенты, разместившие заказы на 2023 03 22 дату */
SELECT customer_name [ФИО клиента]
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE order_date = '2023-03-22');

/* клиенты, разместившие заказы на товары по цене, превышающей среднюю цену всех товаров. */
SELECT customer_name [ФИО клиента]
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE product_id IN (SELECT product_id FROM products WHERE price > (SELECT AVG(price) FROM products)));

/* продукты, которые были заказаны конкретным клиентом */
SELECT product_name [Название продукта]
FROM products
WHERE product_id IN (SELECT product_id FROM orders WHERE customer_id = (SELECT customer_id FROM customers WHERE customer_name = 'Иванова Ольга'));

/*
1) Возможности использования подзапросов в MS SQL Server:
   1.1) Подзапрос в предикате WHERE: Вы можете использовать подзапрос для фильтрации строк, основываясь на результате другого запроса. 
Например, вы можете использовать подзапрос, чтобы найти все заказы от клиентов определенного города.
   1.2) Подзапрос в предикате FROM: Вы можете использовать подзапрос в качестве источника данных для создания временной таблицы, 
которая затем может быть использована в основном запросе. Например, вы можете использовать подзапрос для создания таблицы, 
содержащей данные о среднем заказе для каждого клиента, а затем использовать эту таблицу в основном запросе.
   1.3) Подзапрос в предикате HAVING: Подзапросы также могут быть использованы в предикате HAVING для фильтрации группированных результатов. 
Например, вы можете использовать подзапрос, чтобы найти группы суммарных продаж, превышающих определенное значение.
   1.4) Подзапрос в предикате SELECT: Вы можете использовать подзапрос, чтобы включить вычисленное значение в основной запрос. 
Например, вы можете использовать подзапрос, чтобы найти сумму всех заказов и включить это значение в результирующий набор.
2) Подзапрос возвращает набор данных, который может содержать одну или несколько строк и столбцов. 
Результат подзапроса может быть использован в основном запросе для фильтрации данных, выполнения вычислений или создания временных таблиц.
3) Если подзапрос возвращает более одного значения, необходимо использовать предикаты IN, 
ANY или ALL для сравнения результата подзапроса с другими значениями. Например, вы можете использовать предикат IN, 
чтобы проверить, содержится ли значение в результирующем наборе подзапроса.
4) Да, подзапросы могут быть использованы при выполнении операций добавления (INSERT), изменения (UPDATE) и удаления (DELETE) в MS SQL Server. Например, вы можете использовать подзапрос в предложении VALUES для вставки данных из другой таблицы, или в предложении SET для обновления значений в соответствии с результатом подзапроса.
*/